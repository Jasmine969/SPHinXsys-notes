# generateParticles<BaseParticles, Lattice>()

当用户调用`water_block.generateParticles<BaseParticles, Lattice>()`时，会进入以下函数：

```cpp
//----------------------------------------------------------------------
// Particle generating methods
// Initialize particle data using a particle generator for geometric data.
// The local material parameters are also initialized.
//----------------------------------------------------------------------
template <class ParticleType, class... Parameters, typename... Args>
ParticleType *SPHBody::generateParticles(Args &&...args)
{
    ParticleType *particles = base_particles_ptr_keeper_.createPtr<ParticleType>(*this, base_material_); // 1
    ParticleGenerator<ParticleType, Parameters...> particle_generator(*this, *particles, std::forward<Args>(args)...); // 2
    particle_generator.generateParticlesWithGeometricVariables(); // 3
    particles->initializeBasicParticleVariables(); // 4
    sph_adaptation_->initializeAdaptationVariables(*particles); // 5
    base_material_->setLocalParameters(sph_system_, particles); // 6
    return particles;
};
```

**编译阶段**：模板参数`ParticleType`被推断为`BaseParticles`，`Parameters`被推断为`Lattice`，`Args`和`args`为空参数包。

**运行阶段**：

1. 创建`BaseParticles`的`unique_ptr`。此时会调用`BaseParticles`的构造函数。构造函数主要做的是初始化粒子属性（位置、密度、体积、质量等）为`nullptr`。

2. 调用`ParticleGenerator<BaseParticles, Lattice> particle_generator(*this, *particles);`。此时调用`ParticleGenerator<BaseParticles, Lattice>`的构造函数：

   ```cpp
   ParticleGenerator<BaseParticles, Lattice>::
       ParticleGenerator(SPHBody &sph_body, BaseParticles &base_particles)
       : ParticleGenerator<BaseParticles>(sph_body, base_particles),
         GeneratingMethod<Lattice>(sph_body) {}
   ```

   - 进入`ParticleGenerator<BaseParticles>`构造函数。

     ```cpp
     ParticleGenerator<BaseParticles>::
         ParticleGenerator(SPHBody &sph_body, BaseParticles &base_particles)
         : base_particles_(base_particles),
           particle_spacing_ref_(sph_body.getSPHAdaptation().ReferenceSpacing()) {}
     ```

     `ParticleGenerator<BaseParticles>`构造完毕。

   - 进入`GeneratingMethod<Lattice>`构造函数：

     ```cpp
     GeneratingMethod<Lattice>::GeneratingMethod(SPHBody &sph_body)
         : lattice_spacing_(sph_body.getSPHAdaptation().ReferenceSpacing()),
           domain_bounds_(sph_body.getSPHSystemBounds()),
           initial_shape_(sph_body.getInitialShape())
     {
         if (!initial_shape_.isValid())
         {
             std::cout << "\n BaseParticleGeneratorLattice Error: initial_shape_ is invalid." << std::endl;
             std::cout << __FILE__ << ':' << __LINE__ << std::endl;
             throw;
         }
     }
     ```

     `GeneratingMethod<Lattice>`构造完毕。

   `ParticleGenerator<BaseParticles, Lattice>`构造完毕。

3. 调用`particle_generator`对象的`generateParticlesWithGeometricVariables()`成员函数。这不是一个虚函数，对所有派生类来说都一样：

   ```cpp
   void ParticleGenerator<BaseParticles>::generateParticlesWithGeometricVariables()
   {
       prepareGeometricData(); // 虚函数
       setAllParticleBounds(); // 虚函数
       initializeParticleVariables(); // 虚函数
   }
   ```

   - 进入`prepareGeometricData()`，对于`ParticleGenerator<BaseParticles, Lattice>`类，这个成员函数没有在`shared`目录中实现，而是在`for_2D_build`和`for_3D_build`中实现。例如`src\for_3D_build\particle_generator\particle_generator_lattice_3d.cpp`：

     ```cpp
     void ParticleGenerator<BaseParticles, Lattice>::prepareGeometricData()
     {
         // 构建3D网格
         Mesh mesh(domain_bounds_, lattice_spacing_, 0);
         // 体积=ΔL^3
         Real particle_volume = lattice_spacing_ * lattice_spacing_ * lattice_spacing_;
         Arrayi number_of_lattices = mesh.AllCells();
         // 把粒子依次放在网格中心
         for (int i = 0; i < number_of_lattices[0]; ++i)
             for (int j = 0; j < number_of_lattices[1]; ++j)
                 for (int k = 0; k < number_of_lattices[2]; ++k)
                 {
                     Vecd particle_position = mesh.CellPositionFromIndex(Arrayi(i, j, k));
                     if (initial_shape_.checkNotFar(particle_position, lattice_spacing_))
                     {
                         if (initial_shape_.checkContain(particle_position))
                         {
                             addPositionAndVolumetricMeasure(particle_position, particle_volume);
                         }
                     }
                 }
     }
     ```

     退出`prepareGeometricData()`。

   - 进入`setAllParticleBounds()`。`ParticleGenerator<BaseParticles, Lattice>`没有实现自己的这个成员函数，所以调用基类的成员函数：

     ```cpp
     void ParticleGenerator<BaseParticles>::setAllParticleBounds()
     {
         base_particles_.initializeAllParticlesBounds(position_.size());
     }
     ```

     作用是将real particles的数量（`sv_total_real_particles_`）和总粒子数量（`particle_bound_`）均设为`prepareGeometricData`中创建的粒子数目。

     退出`setAllParticleBounds()`。

   - 进入`initializeParticleVariables()`。目的是注册粒子的位置和体积：

     ```cpp
     void ParticleGenerator<BaseParticles>::initializeParticleVariables()
     {
         base_particles_.registerPositionAndVolumetricMeasure(position_, volumetric_measure_);
     }
     ```

     - 进入`registerPositionAndVolumetricMeasure`：

       ```cpp
       void BaseParticles::registerPositionAndVolumetricMeasure(StdVec<Vecd> &pos, StdVec<Real> &Vol)
       {
           dv_pos_ = registerStateVariableFrom<Vecd>("Position", pos);
           Vol_ = registerStateVariableDataFrom<Real>("VolumetricMeasure", Vol);
       }
       ```

       退出`registerPositionAndVolumetricMeasure`。

     退出`initializeParticleVariables()`。

   退出`generateParticlesWithGeometricVariables()`。

4. 调用`particles->initializeBasicParticleVariables()`。进入`initializeBasicParticleVariables()`：

   ```cpp
   void BaseParticles::initializeBasicParticleVariables()
   {
       addEvolvingVariable<Vecd>("Position");
       addEvolvingVariable<Real>("VolumetricMeasure");
       //----------------------------------------------------------------------
       //		register non-geometric variables
       //----------------------------------------------------------------------
       rho_ = registerStateVariableData<Real>("Density", base_material_.ReferenceDensity());
       mass_ = registerStateVariableData<Real>("Mass",
                                               [&](size_t i) -> Real
                                               { return rho_[i] * ParticleVolume(i); });
       //----------------------------------------------------------------------
       //		unregistered variables and data
       //----------------------------------------------------------------------
       original_id_ = registerDiscreteVariableData<UnsignedInt>("OriginalID", particles_bound_, AssignIndex());
       addEvolvingVariable<UnsignedInt>("OriginalID");
       addVariableToWrite<UnsignedInt>("OriginalID");
       sorted_id_ = registerDiscreteVariableData<UnsignedInt>("SortedID", particles_bound_, AssignIndex());
   }
   ```

   退出`initializeBasicParticleVariables()`。

5. 调用`sph_adaptation_->initializeAdaptationVariables(*particles)`。如果没有特别adaptation，什么也不做。

6. 调用`base_material_->setLocalParameters(sph_system_, particles)`。

# generateParticlesWithReserve<BaseParticles, Lattice>(inlet_particle_buffer)

```cpp
ParticleBuffer<ReserveSizeFactor> inlet_particle_buffer(0.5);
water_block.generateParticlesWithReserve<BaseParticles, Lattice>(inlet_particle_buffer);
```

太长不看：`generateParticlesWithReserve<BaseParticles, Lattice>(inlet_particle_buffer)`在`generateParticles<BaseParticles, Lattice>()`的基础上，在`particle_generator.generateParticlesWithGeometricVariables()`的`setAllParticleBounds()`中将`particles_bound_`递增`buffer_size`（因为用户传入了0.5，所以递增real particle数目的一半），并设置`inlet_particle_buffer`的`is_particles_reserved_`属性为`true`。

首先调用`generateParticles<BaseParticles, ParticleBuffer<ReserveSizeFactor>, Lattice>(inlet_particle_buffer)`

进一步构造`ParticleGenerator<BaseParticles, ParticleBuffer<ReserveSizeFactor>, Lattice>(*this, *particles, inlet_particle_buffer)`。

`ParticleGenerator<BaseParticles, ParticleBuffer<ReserveSizeFactor>, Lattice>`继承于`ParticleGenerator<BaseParticles, Lattice>`，唯一区别是覆盖了`setAllParticleBounds()`：

```cpp
template <class ParticlesType, class BufferSizeEstimator, typename... OtherParameters>
class ParticleGenerator<ParticlesType, ParticleBuffer<BufferSizeEstimator>, OtherParameters...>
    : public ParticleGenerator<ParticlesType, OtherParameters...>
{
  public:
    template <typename... Args>
    ParticleGenerator(SPHBody &sph_body, ParticlesType &particles,
                      ParticleBuffer<BufferSizeEstimator> &buffer_boundary, Args &&...args)
        : ParticleGenerator<ParticlesType, OtherParameters...>(sph_body, particles, std::forward<Args>(args)...),
          buffer_boundary_(buffer_boundary)
    {
        static_assert(!has_ghost_particles<ParticleGenerator<ParticlesType, OtherParameters...>>::value,
                      "ParticleGenerator: GhostReservation is not allowed ahead of BufferReservation.");
    };
    virtual ~ParticleGenerator() {};

    virtual void setAllParticleBounds() override
    {
        ParticleGenerator<ParticlesType, OtherParameters...>::setAllParticleBounds();
        buffer_boundary_.reserveBufferParticles(this->base_particles_, this->particle_spacing_ref_);
    };

  private:
    ParticleBuffer<BufferSizeEstimator> &buffer_boundary_;
};
```

**编译阶段**，`BufferSizeEstimator`被推断为`ReserveSizeFactor`。

**运行阶段**，在`ParticleGenerator<BaseParticles, ParticleBuffer<ReserveSizeFactor>, Lattice>::setAllParticleBounds()`中，首先调用基类`ParticleGenerator<BaseParticles, Lattice>::setAllParticleBounds()`，然后调用`ParticleBuffer<ReserveSizeFactor>`的`reserveBufferParticles`成员函数：

```cpp
template <class BufferSizeEstimator>
class ParticleBuffer<BufferSizeEstimator> : public ParticleBuffer<Base>
{
  public:
    template <typename... Args>
    ParticleBuffer(Args &&...args) : ParticleBuffer<Base>(), buffer_size_estimator_(std::forward<Args>(args)...){};
    virtual ~ParticleBuffer() {};
    void reserveBufferParticles(BaseParticles &base_particles, Real particle_spacing)
    {
        size_t buffer_size = buffer_size_estimator_(base_particles, particle_spacing); // 1
        allocateBufferParticles(base_particles, buffer_size); // 2
        is_particles_reserved_ = true; // 3
    };

  private:
    BufferSizeEstimator buffer_size_estimator_;
};
```

1. 调用`ReserveSizeFactor`的`()`运算符：

   ```cpp
   size_t ReserveSizeFactor::operator()(BaseParticles &base_particles, Real particle_spacing)
   {
       return std::ceil(Real(base_particles.TotalRealParticles()) * size_factor_);
   }
   ```

   用户指定`size_factor_`为0.5，所以返回给`buffer_size`的值是当前real particle数目的一半。

   退出`ReserveSizeFactor`的`()`运算。

2. 调用`allocateBufferParticles(base_particles, buffer_size)`，不是虚函数，直接调用基类的：

   ```cpp
   void ParticleBuffer<Base>::allocateBufferParticles(BaseParticles &base_particles, size_t buffer_size)
   {
       base_particles.increaseParticlesBounds(buffer_size);
   }
   ```

   `particles_bound_`递增`buffer_size`。

   退出`allocateBufferParticles(base_particles, buffer_size)`。

3. `is_particles_reserved_ = true`。

