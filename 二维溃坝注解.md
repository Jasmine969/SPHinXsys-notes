# 前置知识

参数包转发、智能指针、运行时类型识别。

矩形几何创建时默认以原点为中心。通过Transform命令，把左下角平移到原点位置。

![](https://fengimages-1310812903.cos.ap-shanghai.myqcloud.com/20251205152139.png)



```cpp
class WallBoundary : public ComplexShape
{
  public:
    explicit WallBoundary(const std::string &shape_name) : ComplexShape(shape_name)
    {
        // WallBoundary继承于ComplexShape，后者又继承于BinaryShape，BinaryShape具有add成员函数
        // add成员函数将在其sub_shape_ptrs_keeper_（储存unique_ptr<Shape*>的vector）添加一个指向GeometricShapeBox对象的Shape指针
        // 然后在sub_shapes_and_ops_（储存pair<Shape *, ShapeBooleanOps>的vector）中添加一个pair：(上面创建的Shape指针,add)
        // 创建指向GeometricShapeBox对象的Shape指针时，使用的参数为Transform(outer_wall_translation)和outer_wall_halfsize，其中前者调用了构造函数explicit BaseTransform::BaseTransform(const VecType &translation)表示平移变换，后者表示盒子一半尺寸，将传入GeometricBox的构造函数
        add<GeometricShapeBox>(Transform(outer_wall_translation), outer_wall_halfsize);
        subtract<GeometricShapeBox>(Transform(inner_wall_translation), inner_wall_halfsize);
    }
};
```

# main函数

```cpp
    // 定义二维盒子边界，使用左下角（坐标最小的）和右上角（坐标最大的）
    BoundingBox system_domain_bounds(Vec2d(-BW, -BW), Vec2d(DL + BW, DH + BW));
    // 定义系统，使用定义好的系统边界与粒子间距
    SPHSystem sph_system(system_domain_bounds, particle_spacing_ref);
```

在SPHinXsys中，定义一个body有以下5种方式：

```cpp
SPHBody(SPHSystem &sph_system, Shape &shape, const std::string &name);
SPHBody(SPHSystem &sph_system, Shape &shape);
SPHBody(SPHSystem &sph_system, const std::string &name);
SPHBody(SPHSystem &sph_system, SharedPtr<Shape> shape_ptr, const std::string &name);
SPHBody(SPHSystem &sph_system, SharedPtr<Shape> shape_ptr);
```

定义water_block时使用的是第二个，定义SolidBody对象时使用的是第五个。当没有传入名字时，默认使用shape的名字（见base_body.cpp的20行和32行）。

```cpp
    FluidBody water_block(sph_system, initial_water_block);
	// 定义材料，rho0f和c_f是初始化WeaklyCompressibleFluid的参数
    water_block.defineMaterial<WeaklyCompressibleFluid>(rho0_f, c_f);
	// 生成颗粒，模板参数中第一个是颗粒类型，第二个是
    water_block.generateParticles<BaseParticles, Lattice>();

    SolidBody wall_boundary(sph_system, makeShared<WallBoundary>("WallBoundary"));
    wall_boundary.defineMaterial<Solid>();
    wall_boundary.generateParticles<BaseParticles, Lattice>();
```

定义观测点，大概是为了回归测试的。

```cpp
    ObserverBody fluid_observer(sph_system, "FluidObserver");
    StdVec<Vecd> observation_location = {Vecd(DL, 0.2)};
    fluid_observer.generateParticles<ObserverParticles>(observation_location);
```

定义拓扑关系。类似于LAMMPS中的`pair_coeff I J`，指定哪两类粒子之间要建立邻居表。`ComplexRelation`不是为了建立邻居表，而是为了更新配置。

```cpp
    //----------------------------------------------------------------------
    //	Define body relation map.
    //	The contact map gives the topological connections between the bodies.
    //	Basically the the range of bodies to build neighbor particle lists.
    //  Generally, we first define all the inner relations, then the contact relations.
    //----------------------------------------------------------------------
    InnerRelation water_block_inner(water_block);
    ContactRelation water_wall_contact(water_block, {&wall_boundary});
    ContactRelation fluid_observer_contact(fluid_observer, {&water_block});
    // Combined relations built from basic relations
    // which is only used for update configuration.
    //----------------------------------------------------------------------
    ComplexRelation water_wall_complex(water_block_inner, water_wall_contact);
```

## 规定数值方法

`SimpleDynamics`是一个不考虑粒子间相互作用的简单粒子动力学算法模板类。`NormalDirectionFromBodyShape` 是局部动力学类，用于从物体形状计算粒子的法向方向。这确保了墙体边界的每个粒子都有正确的法向量，这对于后续的流固耦合计算（如Riemann求解器）至关重要，用于正确处理流体与墙体的相互作用。

```cpp
    //----------------------------------------------------------------------
    // Define the numerical methods used in the simulation.
    // Note that there may be data dependence on the sequence of constructions.
    // Generally, the geometric models or simple objects without data dependencies,
    // such as gravity, should be initiated first.
    // Then the major physical particle dynamics model should be introduced.
    // Finally, the auxiliary models such as time step estimator, initial condition,
    // boundary condition and other constraints should be defined.
    //----------------------------------------------------------------------
    Gravity gravity(Vecd(0.0, -gravity_g));
    c<GravityForce<Gravity>> constant_gravity(water_block, gravity);
    SimpleDynamics<NormalDirectionFromBodyShape> wall_boundary_normal_direction(wall_boundary);
```

`Dynamics1Level`是最复杂的粒子动力学算法，通常是流体动力学或固体动力学算法的具体实现，包含完整的三步骤初始化`initialization(i, dt)`、粒子间相互作用`interaction(i, dt)`、状态更新`update(i, dt)`。

```cpp
    Dynamics1Level<fluid_dynamics::Integration1stHalfWithWallRiemann> fluid_pressure_relaxation(water_block_inner, water_wall_contact);
    Dynamics1Level<fluid_dynamics::Integration2ndHalfWithWallRiemann> fluid_density_relaxation(water_block_inner, water_wall_contact);
```

关于fluid_integration相关类的详细介绍见[此](./fluid integration梳理.md)。`Integration1stHalfWithWallRiemann`是一个复合类型，既有内部交互，也有流体与壁面交互，使用Riemann solver实现物理场的稳定化，没有核函数修正。与`2ndHalf`系列相比，它执行对动量方程的离散实现。执行如下操作（`src\shared\particle_dynamics\fluid_dynamics\fluid_integration.hpp`）：

```cpp
// 1. 流体内部initialization() - 更新半步密度、压力、位置
rho_[index_i] += drho_dt_[index_i] * dt * 0.5;
p_[index_i] = fluid_.getPressure(rho_[index_i]);
pos_[index_i] += vel_[index_i] * dt * 0.5;

// 2. 流体内部interaction() - 搜索邻居表，计算压力梯度力
force -= (p_[index_i] * correction_(index_j) + p_[index_j] * correction_(index_i)) * dW_ijV_j * e_ij;
rho_dissipation += riemann_solver_.DissipativeUJump(p_[index_i] - p_[index_j]) * dW_ijV_j;

// 3. 流体与壁面interaction() - 搜索邻居表，计算压力梯度力
force -= (p_[index_i] + p_j_in_wall) * correction_(index_i) * dW_ijV_j * e_ij;
rho_dissipation += riemann_solver_.DissipativeUJump(p_[index_i] - p_j_in_wall) * dW_ijV_j;

// 4. update() - 更新一步速度
vel_[index_i] += (force_prior_[index_i] + force_[index_i]) / mass_[index_i] * dt;
```

`Integration2ndHalfWithWallRiemann`是一个复合类型，既有内部交互，也有流体与壁面交互，使用Riemann solver实现物理场的稳定化，没有核函数修正。与`1stHalf`系列相比，它执行对连续性方程的离散实现。执行如下操作（`src\shared\particle_dynamics\fluid_dynamics\fluid_integration.hpp`）：

```cpp
// 1. 流体内部initialization() - 更新半步位置
pos_[index_i] += vel_[index_i] * dt * 0.5;

// 2. 流体内部interaction() - 搜索邻居表，计算速度散度引起的密度变化
Real u_jump = (vel_[index_i] - vel_[index_j]).dot(e_ij);
density_change_rate += u_jump * dW_ijV_j;
p_dissipation += riemann_solver_.DissipativePJump(u_jump) * dW_ijV_j * e_ij;

// 3. 流体与壁面interaction() - 搜索邻居表，计算速度散度引起的密度变化
density_change_rate += (vel_[index_i] - vel_j_in_wall).dot(e_ij) * dW_ijV_j;
Real u_jump = 2.0 * (vel_[index_i] - vel_ave_k[index_j]).dot(n_k[index_j]);
p_dissipation += riemann_solver_.DissipativePJump(u_jump) * dW_ijV_j * n_k[index_j];

// 4. 流体内部update() - 更新一步密度
rho_[index_i] += drho_dt_[index_i] * dt * 0.5;
```

`InteractionWithUpdate`没有initialization，只有interaction和update。

```cpp
    InteractionWithUpdate<fluid_dynamics::DensitySummationComplexFreeSurface> fluid_density_by_summation(water_block_inner, water_wall_contact);
```

`ReduceDynamics`一般用来求全局的归约值（最大、最小、求和等）这两个`ReduceDynamics`用来计算Dual-criteria timestepping中的对流时间步长和声学时间步长

```cpp
    ReduceDynamics<fluid_dynamics::AdvectionTimeStep> fluid_advection_time_step(water_block, U_ref);
    ReduceDynamics<fluid_dynamics::AcousticTimeStep> fluid_acoustic_time_step(water_block);
```

