# 编译方法

如果项目根目录没有`user_examples`（v1.2.1-sycl没有），建立`user_examples`，并把master分支的`user_examples/CMakeLists.txt`拷贝过来。

拷贝一个tests中的案例到`user_examples`，例如：

```bash
cd user_examples
cp ../2d_examples/test_2d_elastic_gate -r jsm_2d_elastic_gate
```

然后在build目录增量构建（无需清理build目录），也就是重复运行一遍cmake：

```bash
cd ../../build
cmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_C_COMPILER_LAUNCHER=ccache -D CMAKE_CXX_COMPILER_LAUNCHER=ccache -DSPHINXSYS_BUILD_USER_EXAMPLES=ON -S ..
```

然后只编译新案例的可执行文件`jsm_2d_elastic_gate`：

```bash
make jsm_2d_elastic_gate
```

以下是终端的输出：

```bash
[jsm@server build]$ make jsm_2d_elastic_gate
[100%] Built target sphinxsys_2d
[100%] Building CXX object tests/user_examples/jsm_2d_elastic_gate/CMakeFiles/jsm_2d_elastic_gate.dir/elastic_gate.cpp.o
[100%] Linking CXX executable bin/jsm_2d_elastic_gate
/opt/gcc-13.4.0/bin/g++ -O3 -DNDEBUG -Wl,--dependency-file,CMakeFiles/jsm_2d_elastic_gate.dir/link.d CMakeFiles/jsm_2d_elastic_gate.dir/elastic_gate.cpp.o -o bin/jsm_2d_elastic_gate  -Wl,-rpath,/opt/sphinxsys-soft/Simbody-3.7/lib64:/opt/OpenBLAS/lib:/opt/sphinxsys-soft/oneTBB-2022.3.0/lib64:/opt/sphinxsys-soft/Boost-1.88.0/lib ../../../src/libsphinxsys_2d.a /opt/sphinxsys-soft/Simbody-3.7/lib64/libSimTKsimbody.so.3.7 /opt/sphinxsys-soft/Simbody-3.7/lib64/libSimTKmath.so.3.7 /opt/sphinxsys-soft/Simbody-3.7/lib64/libSimTKcommon.so.3.7 /opt/OpenBLAS/lib/libopenblas.so -lm -ldl -lpthread -lrt -ldl -lm /opt/sphinxsys-soft/oneTBB-2022.3.0/lib64/libtbb.so.12.17 /opt/sphinxsys-soft/oneTBB-2022.3.0/lib64/libtbbmalloc.so.2.17 /opt/sphinxsys-soft/Boost-1.88.0/lib/libboost_program_options.so.1.88.0 /opt/sphinxsys-soft/googletest-1.17.0/lib64/libgtest_main.a /opt/sphinxsys-soft/googletest-1.17.0/lib64/libgtest.a -lpthread
[100%] Built target jsm_2d_elastic_gate
```

如果要写一个全新的案例，需要自己写CMakeLists.txt。先学习案例的CMakeLists.txt是怎么写的。

# 案例CMakeLists注解

以`tests\2d_examples\test_2d_dambreak`为例。

全局变量含义：

| 变量名                     | 含义 | 值                                                           |
| -------------------------- | ---- | ------------------------------------------------------------ |
| `CMAKE_MODULE_PATH`        | CMake 查找模块（`include()`/`find_package()`等）时的额外搜索路径列表（分号分隔） | `...;SPHinXsys-v.1.2.1-sycl/cmake`（本例在子目录里又追加了一次，可能出现重复） |
| `CMAKE_SOURCE_DIR`         | 顶层源码目录（你从哪里作为“顶层工程”执行 `cmake -S`） | `SPHinXsys-v.1.2.1-sycl` |
| `CMAKE_CURRENT_SOURCE_DIR` | 当前处理的`CMakeLists.txt`所在的源码目录 | `SPHinXsys-v.1.2.1-sycl/tests/2d_examples/test_2d_dambreak` |
| `PROJECT_BINARY_DIR`       | 当前`project(...)`对应的构建目录（本工程是 out-of-source build，因此在 build 目录下） | `SPHinXsys-v.1.2.1-sycl/build/tests/2d_examples/test_2d_dambreak` |
| `CMAKE_CURRENT_BINARY_DIR` | 案例build路径 | `build/tests/user_examples/jsm_2d_dambreak` |
| `LIBRARY_OUTPUT_PATH`      | （旧式变量）本案例生成的库文件输出目录 | `SPHinXsys-v.1.2.1-sycl/build/tests/2d_examples/test_2d_dambreak/lib` |
| `EXECUTABLE_OUTPUT_PATH`   | （旧式变量）本案例生成的可执行文件输出目录 | `SPHinXsys-v.1.2.1-sycl/build/tests/2d_examples/test_2d_dambreak/bin/` |
| `CMAKE_COMMAND`            | CMake 可执行程序路径（用于`cmake -E ...`这类命令） | 例如：`/usr/bin/cmake`（或你的环境中实际的 cmake 路径） |
| `PROJECT_NAME`             | 当前`project(...)`的工程名；本例被设置为“当前文件夹名”，也用作target名 | `test_2d_dambreak` |

`tests\2d_examples\test_2d_dambreak\CMakeLists.txt`：

```cmake
# 把顶层工程的cmake加到模块搜索路径里，方便include()/find_package()找到自定义CMake脚本。
# 这里用的是CMAKE_SOURCE_DIR（顶层源码目录）。在user_examples里用SPHINXSYS_PROJECT_DIR也是同一个目的。
set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_SOURCE_DIR}/cmake) # main (top) cmake dir

# 输出更详细的编译命令
set(CMAKE_VERBOSE_MAKEFILE on)

#这两行取目录名当工程名/target名
STRING(REGEX REPLACE ".*/(.*)" "\\1" CURRENT_FOLDER ${CMAKE_CURRENT_SOURCE_DIR})
PROJECT("${CURRENT_FOLDER}")

# 把这个case生成的库/可执行文件统一放到该case自己的build子目录，并额外约定bin/input、bin/reload这种运行时目录。
# ${PROJECT_BINARY_DIR}展开为
# LIBRARY_OUTPUT_PATH/EXECUTABLE_OUTPUT_PATH属于较老的全局变量风格（不是现代target级别的RUNTIME_OUTPUT_DIRECTORY）。在这个工程里很多例子都这么写，保持一致就行。
SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) # 指定案例的lib目录生成在哪里
SET(EXECUTABLE_OUTPUT_PATH "${PROJECT_BINARY_DIR}/bin/") # 指定案例的bin目录生成在哪里
SET(BUILD_INPUT_PATH "${EXECUTABLE_OUTPUT_PATH}/input")
SET(BUILD_RELOAD_PATH "${EXECUTABLE_OUTPUT_PATH}/reload") 

# 准备运行输入目录，并拷贝回归测试工具
# file和execute_process两行命令都是在创建bin/input目录；两句有点重复，但效果就是确保目录存在。
file(MAKE_DIRECTORY ${BUILD_INPUT_PATH})
execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory ${BUILD_INPUT_PATH})
# 把当前case下的regression_test_tool/拷贝到bin/input/，保证运行或回归测试时能找到工具/基准数据。
file(COPY ${CMAKE_CURRENT_SOURCE_DIR}/regression_test_tool/ DESTINATION ${BUILD_INPUT_PATH})

# 收集源文件并生成可执行文件
# 把当前目录下所有源文件（通常是.cpp）收集到DIR_SRCS。
# 这是“目录扫源文件”的老写法：新增/删除源文件时通常需要重新cmake一次让它重新扫描。
aux_source_directory(. DIR_SRCS)
# 生成可执行 target，名字为 ${PROJECT_NAME}（也就是目录名）。
# 这里把 ${EXECUTABLE_OUTPUT_PATH} 当成了一个“源文件参数”传进去其实没意义（它不是源文件）；多数情况下不会直接报错，但严格来说这是不规范的写法。真正决定输出路径的是上面那个 EXECUTABLE_OUTPUT_PATH 变量。
add_executable(${PROJECT_NAME} ${EXECUTABLE_OUTPUT_PATH} ${DIR_SRCS})
# 仅对 Visual Studio调试有用：设置调试运行时的工作目录为bin/，这样相对路径读写文件不容易出问题。
set_target_properties(${PROJECT_NAME} PROPERTIES VS_DEBUGGER_WORKING_DIRECTORY "${EXECUTABLE_OUTPUT_PATH}")
# 把这个例子链接到 sphinxsys_2d 库（2D 版本的 SPHinXsys）
target_link_libraries(${PROJECT_NAME} sphinxsys_2d)

# 注册为ctest测试（两条）
# 此时已经生成可执行文件。TEST_STATE_RECORDING的值在根目录CMakeLists.txt定义为ON。
# 相当于在EXECUTABLE_OUTPUT_PATH执行./test_2d_dambreak --state_recording=ON
add_test(NAME ${PROJECT_NAME} COMMAND ${PROJECT_NAME} --state_recording=${TEST_STATE_RECORDING}
    WORKING_DIRECTORY ${EXECUTABLE_OUTPUT_PATH})
    # 相当于在EXECUTABLE_OUTPUT_PATH执行./test_2d_dambreak --restart_step=4000 --state_recording=ON
add_test(NAME ${PROJECT_NAME}_restart COMMAND ${PROJECT_NAME} --restart_step=4000 --state_recording=${TEST_STATE_RECORDING}
    WORKING_DIRECTORY ${EXECUTABLE_OUTPUT_PATH})
```

# 更现代的CMakeLists

让GPT-5.2仿照案例的CMakeLists，帮我改了一个更现代的版本。这里没有ctest测试了。

```cmake
# A more modern, robust variant of the example CMakeLists.txt.
# Intended to be used when this directory is added via add_subdirectory() from the main SPHinXsys build.

# 从当前源码目录路径中取最后一级目录名
# 比原来用正则STRING(REGEX REPLACE ...)更稳，跨平台路径分隔符也不容易踩坑。
get_filename_component(CASE_NAME "${CMAKE_CURRENT_SOURCE_DIR}" NAME)
#定义一个变量保存 target 名，后续统一用 ${TARGET_NAME}。
set(TARGET_NAME "${CASE_NAME}")

# --- Output layout (case-local)
# 定义该案例的可执行文件输出目录（构建目录下的 bin）
set(CASE_BIN_DIR "${CMAKE_CURRENT_BINARY_DIR}/bin")
# 定义该案例的库输出目录（如果未来生成静态/动态库时用）
set(CASE_LIB_DIR "${CMAKE_CURRENT_BINARY_DIR}/lib")

# --- Sources (auto-pickup; adding/removing files triggers reconfigure)
# 在配置阶段扫描当前目录下的源文件，匹配 *.cpp/*.cc/*.cxx，把结果放进 CASE_SOURCES。
# CONFIGURE_DEPENDS 的意思是：当目录下匹配结果变化（新增/删除文件）时，会触发CMake重新配置，从而更新构建系统。
# 这比 aux_source_directory()更可控一些，也比手写源文件列表更省事（但本质仍是“glob”，大型项目里有时更推荐显式列出源文件）
file(GLOB CASE_SOURCES CONFIGURE_DEPENDS
    "${CMAKE_CURRENT_SOURCE_DIR}/*.cpp"
    "${CMAKE_CURRENT_SOURCE_DIR}/*.cc"
    "${CMAKE_CURRENT_SOURCE_DIR}/*.cxx"
)

# 现代 CMake 推荐把“东西都挂到target上”（sources/includes/defines/options/link libs），因为 target 自己带边界（PUBLIC/PRIVATE/INTERFACE）和可读性。
# 声明一个可执行target，但先不把源文件塞进去（空 target）
add_executable(${TARGET_NAME})
# 把上面扫描到的源文件作为“私有源文件”加到该 target。
# PRIVATE：这些源文件只属于该 target，不会传播给依赖它的其它 target（对可执行文件来说这基本就是常规写法）
target_sources(${TARGET_NAME} PRIVATE ${CASE_SOURCES})

# Link against the SPHinXsys 2D library target provided by the main project.
# 把可执行文件链接到主工程里的 sphinxsys_2d 库 target。
# PRIVATE：链接依赖不会传播（对 exe 也合理）。
# 前提：你是从 SPHinXsys 顶层工程构建，顶层已经定义/生成了 sphinxsys_2d 这个 target
target_link_libraries(${TARGET_NAME} PRIVATE sphinxsys_2d)

# Place the executable and any produced libraries into case-local bin/lib directories.
# 给这个 target 设置一组属性

set_target_properties(${TARGET_NAME} PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY "${CASE_BIN_DIR}" # 可执行文件输出到.../bin（不再靠旧变量 EXECUTABLE_OUTPUT_PATH影响全局）
    LIBRARY_OUTPUT_DIRECTORY "${CASE_LIB_DIR}" # 若该 target 生成动态库（对 exe 通常不会用到），输出到 lib
    ARCHIVE_OUTPUT_DIRECTORY "${CASE_LIB_DIR}" # 若生成静态库/导入库（archive），输出到lib（对 exe 通常也不会用到，但写上无害）
    VS_DEBUGGER_WORKING_DIRECTORY "${CASE_BIN_DIR}" # Visual Studio调试时的工作目录设为bin，方便相对路径读写文件
)

# --- Runtime input folder
# 拷贝input目录到build案例目录
set(CASE_INPUT_DIR "${CASE_BIN_DIR}/input")
add_custom_command(TARGET ${TARGET_NAME} POST_BUILD
    COMMAND "${CMAKE_COMMAND}" -E make_directory "${CASE_INPUT_DIR}"
    COMMAND "${CMAKE_COMMAND}" -E copy_directory
            "${CMAKE_CURRENT_SOURCE_DIR}/input" 
            "${CASE_INPUT_DIR}"
    VERBATIM
)
```

linux平台简洁版本（无regression_test_tool）：

```cmake
set(CMAKE_VERBOSE_MAKEFILE on)

get_filename_component(CASE_NAME "${CMAKE_CURRENT_SOURCE_DIR}" NAME)
set(TARGET_NAME "${CASE_NAME}")

# --- Output layout (case-local)
set(CASE_BIN_DIR "${CMAKE_CURRENT_BINARY_DIR}/bin")
set(CASE_LIB_DIR "${CMAKE_CURRENT_BINARY_DIR}/lib")

# --- Sources (auto-pickup; adding/removing files triggers reconfigure)
file(GLOB CASE_SOURCES CONFIGURE_DEPENDS
    "${CMAKE_CURRENT_SOURCE_DIR}/*.cpp"
)

add_executable(${TARGET_NAME})
target_sources(${TARGET_NAME} PRIVATE ${CASE_SOURCES})

# Link against the SPHinXsys 2D library target provided by the main project.
target_link_libraries(${TARGET_NAME} PRIVATE sphinxsys_2d)

# Place the executable and any produced libraries into case-local bin/lib directories.
set_target_properties(${TARGET_NAME} PROPERTIES
    RUNTIME_OUTPUT_DIRECTORY "${CASE_BIN_DIR}"
    LIBRARY_OUTPUT_DIRECTORY "${CASE_LIB_DIR}"
    ARCHIVE_OUTPUT_DIRECTORY "${CASE_LIB_DIR}"
)
```

